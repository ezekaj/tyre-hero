# TyreHero Emergency Service - Production CI/CD Pipeline
# GitHub Actions workflow for zero-downtime deployment

name: Production Emergency Service Deploy

on:
  push:
    branches: [main]
    paths:
      - 'src/**'
      - 'package.json'
      - 'package-lock.json'
      - 'Dockerfile'
      - '.github/workflows/**'
  
  workflow_dispatch:
    inputs:
      deployment_type:
        description: 'Deployment Type'
        required: true
        default: 'standard'
        type: choice
        options:
        - standard
        - emergency
        - rollback
      
      target_environment:
        description: 'Target Environment'
        required: true
        default: 'production'
        type: choice
        options:
        - production
        - staging
      
      skip_tests:
        description: 'Skip Tests (Emergency Only)'
        required: false
        default: false
        type: boolean

env:
  AWS_REGION: eu-west-2
  ECR_REPOSITORY: tyrehero/emergency-api
  ECS_SERVICE: tyrehero-emergency-api
  ECS_CLUSTER: tyrehero-production
  
  # Blue-Green Deployment Configuration
  BLUE_TARGET_GROUP: tyrehero-emergency-blue
  GREEN_TARGET_GROUP: tyrehero-emergency-green
  
  # Monitoring Configuration
  SLACK_WEBHOOK: ${{ secrets.SLACK_WEBHOOK_OPERATIONS }}
  SLACK_EMERGENCY_WEBHOOK: ${{ secrets.SLACK_WEBHOOK_EMERGENCY }}
  PAGERDUTY_INTEGRATION_KEY: ${{ secrets.PAGERDUTY_INTEGRATION_KEY }}

jobs:
  # Pre-deployment Checks
  pre_deployment:
    runs-on: ubuntu-latest
    outputs:
      deployment_id: ${{ steps.deployment_id.outputs.id }}
      should_deploy: ${{ steps.checks.outputs.should_deploy }}
      current_image: ${{ steps.current_deployment.outputs.image }}
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          fetch-depth: 2
      
      - name: Generate Deployment ID
        id: deployment_id
        run: |
          DEPLOYMENT_ID="deploy-$(date +%Y%m%d-%H%M%S)-${{ github.sha }}"
          echo "id=$DEPLOYMENT_ID" >> $GITHUB_OUTPUT
          echo "üöÄ Deployment ID: $DEPLOYMENT_ID"
      
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Check Current Deployment
        id: current_deployment
        run: |
          CURRENT_IMAGE=$(aws ecs describe-services \
            --cluster $ECS_CLUSTER \
            --services $ECS_SERVICE \
            --query 'services[0].taskDefinition' \
            --output text | xargs aws ecs describe-task-definition \
            --task-definition | jq -r '.taskDefinition.containerDefinitions[0].image')
          
          echo "current_image=$CURRENT_IMAGE" >> $GITHUB_OUTPUT
          echo "üì¶ Current Image: $CURRENT_IMAGE"
      
      - name: Pre-deployment Health Check
        id: checks
        run: |
          # Check if emergency service is healthy
          HEALTH_STATUS=$(curl -s -o /dev/null -w "%{http_code}" \
            https://api.tyrehero.com/health || echo "000")
          
          if [ "$HEALTH_STATUS" != "200" ]; then
            echo "‚ö†Ô∏è Emergency service is unhealthy (HTTP $HEALTH_STATUS)"
            echo "should_deploy=false" >> $GITHUB_OUTPUT
            
            # Send alert to emergency team
            curl -X POST $SLACK_EMERGENCY_WEBHOOK \
              -H 'Content-type: application/json' \
              --data '{
                "text": "üö® EMERGENCY SERVICE UNHEALTHY - BLOCKING DEPLOYMENT",
                "attachments": [{
                  "color": "danger",
                  "fields": [{
                    "title": "Health Check Status",
                    "value": "'$HEALTH_STATUS'",
                    "short": true
                  }, {
                    "title": "Deployment ID",
                    "value": "'${{ steps.deployment_id.outputs.id }}'",
                    "short": true
                  }]
                }]
              }'
            exit 1
          else
            echo "‚úÖ Emergency service is healthy"
            echo "should_deploy=true" >> $GITHUB_OUTPUT
          fi
      
      - name: Notify Deployment Start
        run: |
          curl -X POST $SLACK_WEBHOOK \
            -H 'Content-type: application/json' \
            --data '{
              "text": "üöÄ Emergency Service Deployment Started",
              "attachments": [{
                "color": "warning",
                "fields": [{
                  "title": "Deployment ID",
                  "value": "'${{ steps.deployment_id.outputs.id }}'",
                  "short": true
                }, {
                  "title": "Trigger",
                  "value": "'${{ github.event_name }}'",
                  "short": true
                }, {
                  "title": "Branch",
                  "value": "'${{ github.ref_name }}'",
                  "short": true
                }, {
                  "title": "Commit",
                  "value": "'${{ github.sha }}'",
                  "short": true
                }]
              }]
            }'

  # Security and Quality Checks
  security_quality:
    runs-on: ubuntu-latest
    needs: pre_deployment
    if: needs.pre_deployment.outputs.should_deploy == 'true' && (github.event.inputs.skip_tests != 'true' || github.event.inputs.deployment_type != 'emergency')
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
      
      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'
      
      - name: Install Dependencies
        run: |
          npm ci --only=production
          npm ci --only=development
      
      - name: Run Unit Tests
        run: |
          npm run test:unit -- --coverage --ci
          npm run test:integration -- --ci
      
      - name: Security Audit
        run: |
          # NPM Security Audit
          npm audit --audit-level high
          
          # OWASP Dependency Check
          wget -q https://github.com/jeremylong/DependencyCheck/releases/download/v8.4.0/dependency-check-8.4.0-release.zip
          unzip -q dependency-check-8.4.0-release.zip
          ./dependency-check/bin/dependency-check.sh \
            --project "TyreHero Emergency Service" \
            --scan . \
            --format JSON \
            --failOnCVSS 7 \
            --exclude "**/node_modules/**"
      
      - name: Code Quality Analysis
        run: |
          # ESLint for code quality
          npm run lint:ci
          
          # TypeScript type checking
          npm run type-check
          
          # SonarQube analysis
          docker run --rm \
            -v $(pwd):/usr/src \
            -e SONAR_HOST_URL="${{ secrets.SONAR_HOST_URL }}" \
            -e SONAR_LOGIN="${{ secrets.SONAR_TOKEN }}" \
            sonarsource/sonar-scanner-cli \
            -Dsonar.projectKey=tyrehero-emergency-service \
            -Dsonar.sources=src \
            -Dsonar.tests=tests \
            -Dsonar.javascript.lcov.reportPaths=coverage/lcov.info
      
      - name: Performance Testing
        run: |
          # Install k6 for load testing
          sudo gpg -k
          sudo gpg --no-default-keyring --keyring /usr/share/keyrings/k6-archive-keyring.gpg --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys C5AD17C747E3415A3642D57D77C6C491D6AC1D69
          echo "deb [signed-by=/usr/share/keyrings/k6-archive-keyring.gpg] https://dl.k6.io/deb stable main" | sudo tee /etc/apt/sources.list.d/k6.list
          sudo apt-get update
          sudo apt-get install k6
          
          # Run performance tests
          k6 run tests/performance/emergency-load-test.js \
            --env BASE_URL=https://api.tyrehero.com \
            --env DURATION=2m \
            --env VUS=50

  # Build and Push Docker Image
  build_push:
    runs-on: ubuntu-latest
    needs: [pre_deployment, security_quality]
    if: needs.pre_deployment.outputs.should_deploy == 'true' && (success() || (github.event.inputs.deployment_type == 'emergency' && github.event.inputs.skip_tests == 'true'))
    outputs:
      image_uri: ${{ steps.build.outputs.image_uri }}
      image_tag: ${{ steps.build.outputs.image_tag }}
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
      
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Login to Amazon ECR
        id: login_ecr
        uses: aws-actions/amazon-ecr-login@v2
      
      - name: Build and Push Docker Image
        id: build
        run: |
          IMAGE_TAG="${{ github.sha }}"
          IMAGE_URI="${{ steps.login_ecr.outputs.registry }}/$ECR_REPOSITORY:$IMAGE_TAG"
          
          # Build optimized production image
          docker build \
            --target production \
            --build-arg NODE_ENV=production \
            --build-arg BUILD_DATE=$(date -u +'%Y-%m-%dT%H:%M:%SZ') \
            --build-arg VCS_REF=${{ github.sha }} \
            --build-arg VERSION=$IMAGE_TAG \
            -t $IMAGE_URI .
          
          # Security scan of the image
          docker run --rm -v /var/run/docker.sock:/var/run/docker.sock \
            -v $(pwd):/app aquasec/trivy:latest \
            image --exit-code 1 --severity HIGH,CRITICAL $IMAGE_URI
          
          # Push to ECR
          docker push $IMAGE_URI
          
          # Also tag as latest for emergency rollbacks
          docker tag $IMAGE_URI ${{ steps.login_ecr.outputs.registry }}/$ECR_REPOSITORY:latest
          docker push ${{ steps.login_ecr.outputs.registry }}/$ECR_REPOSITORY:latest
          
          echo "image_uri=$IMAGE_URI" >> $GITHUB_OUTPUT
          echo "image_tag=$IMAGE_TAG" >> $GITHUB_OUTPUT
          echo "üê≥ Built and pushed: $IMAGE_URI"

  # Blue-Green Deployment
  deploy:
    runs-on: ubuntu-latest
    needs: [pre_deployment, build_push]
    if: needs.pre_deployment.outputs.should_deploy == 'true'
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
      
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Determine Target Environment
        id: target_env
        run: |
          if [ "${{ github.event.inputs.deployment_type }}" == "emergency" ]; then
            echo "üö® Emergency deployment - using fast deployment strategy"
            echo "deployment_strategy=emergency" >> $GITHUB_OUTPUT
            echo "health_check_timeout=60" >> $GITHUB_OUTPUT
          else
            echo "üìà Standard deployment - using blue-green strategy"
            echo "deployment_strategy=blue_green" >> $GITHUB_OUTPUT
            echo "health_check_timeout=300" >> $GITHUB_OUTPUT
          fi
      
      - name: Create New Task Definition
        id: task_def
        run: |
          # Get current task definition
          CURRENT_TASK_DEF=$(aws ecs describe-task-definition \
            --task-definition tyrehero-emergency \
            --query 'taskDefinition' \
            --output json)
          
          # Update with new image
          NEW_TASK_DEF=$(echo $CURRENT_TASK_DEF | jq --arg IMAGE "${{ needs.build_push.outputs.image_uri }}" \
            '.containerDefinitions[0].image = $IMAGE | 
             del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .placementConstraints, .compatibilities, .registeredAt, .registeredBy)')
          
          # Register new task definition
          aws ecs register-task-definition \
            --cli-input-json "$NEW_TASK_DEF" > task_def_output.json
          
          NEW_TASK_DEF_ARN=$(cat task_def_output.json | jq -r '.taskDefinition.taskDefinitionArn')
          echo "task_definition_arn=$NEW_TASK_DEF_ARN" >> $GITHUB_OUTPUT
          echo "üìã New Task Definition: $NEW_TASK_DEF_ARN"
      
      - name: Blue-Green Deployment
        id: deploy
        run: |
          if [ "${{ steps.target_env.outputs.deployment_strategy }}" == "emergency" ]; then
            # Emergency deployment - direct update
            echo "üö® Performing emergency deployment"
            aws ecs update-service \
              --cluster $ECS_CLUSTER \
              --service $ECS_SERVICE \
              --task-definition ${{ steps.task_def.outputs.task_definition_arn }} \
              --force-new-deployment
          else
            # Blue-Green deployment
            echo "üîÑ Performing blue-green deployment"
            
            # Get current target group
            CURRENT_TG=$(aws elbv2 describe-listeners \
              --load-balancer-arn $(aws elbv2 describe-load-balancers \
                --names tyrehero-emergency-alb \
                --query 'LoadBalancers[0].LoadBalancerArn' \
                --output text) \
              --query 'Listeners[0].DefaultActions[0].TargetGroupArn' \
              --output text)
            
            # Determine next target group
            if [[ "$CURRENT_TG" == *"blue"* ]]; then
              NEXT_TG_NAME="$GREEN_TARGET_GROUP"
              CURRENT_COLOR="blue"
              NEXT_COLOR="green"
            else
              NEXT_TG_NAME="$BLUE_TARGET_GROUP"
              CURRENT_COLOR="green"
              NEXT_COLOR="blue"
            fi
            
            echo "üéØ Deploying to $NEXT_COLOR environment"
            echo "current_color=$CURRENT_COLOR" >> $GITHUB_OUTPUT
            echo "next_color=$NEXT_COLOR" >> $GITHUB_OUTPUT
            
            # Update service to use new task definition on next target group
            aws ecs update-service \
              --cluster $ECS_CLUSTER \
              --service "${ECS_SERVICE}-${NEXT_COLOR}" \
              --task-definition ${{ steps.task_def.outputs.task_definition_arn }}
          fi
      
      - name: Wait for Deployment Stability
        run: |
          echo "‚è≥ Waiting for deployment to stabilize..."
          
          if [ "${{ steps.target_env.outputs.deployment_strategy }}" == "emergency" ]; then
            # Wait for emergency deployment
            aws ecs wait services-stable \
              --cluster $ECS_CLUSTER \
              --services $ECS_SERVICE \
              --cli-read-timeout 600 \
              --cli-connect-timeout 60
          else
            # Wait for blue-green deployment
            aws ecs wait services-stable \
              --cluster $ECS_CLUSTER \
              --services "${ECS_SERVICE}-${{ steps.deploy.outputs.next_color }}" \
              --cli-read-timeout 600 \
              --cli-connect-timeout 60
          fi
          
          echo "‚úÖ Deployment stable"
      
      - name: Health Check New Deployment
        id: health_check
        run: |
          echo "üè• Performing health checks on new deployment..."
          
          TIMEOUT=${{ steps.target_env.outputs.health_check_timeout }}
          HEALTH_URL="https://api.tyrehero.com/health"
          
          if [ "${{ steps.target_env.outputs.deployment_strategy }}" == "blue_green" ]; then
            # For blue-green, check the specific target group
            ALB_DNS=$(aws elbv2 describe-load-balancers \
              --names "tyrehero-emergency-alb-${{ steps.deploy.outputs.next_color }}" \
              --query 'LoadBalancers[0].DNSName' \
              --output text)
            HEALTH_URL="https://$ALB_DNS/health"
          fi
          
          # Health check with retry logic
          for i in $(seq 1 $((TIMEOUT/10))); do
            echo "Health check attempt $i..."
            
            HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$HEALTH_URL" || echo "000")
            
            if [ "$HTTP_STATUS" == "200" ]; then
              echo "‚úÖ Health check passed (HTTP $HTTP_STATUS)"
              echo "health_status=healthy" >> $GITHUB_OUTPUT
              break
            elif [ $i -eq $((TIMEOUT/10)) ]; then
              echo "‚ùå Health check failed after $TIMEOUT seconds (HTTP $HTTP_STATUS)"
              echo "health_status=unhealthy" >> $GITHUB_OUTPUT
              exit 1
            else
              echo "‚è≥ Health check failed (HTTP $HTTP_STATUS), retrying in 10s..."
              sleep 10
            fi
          done
      
      - name: Switch Traffic (Blue-Green Only)
        if: steps.target_env.outputs.deployment_strategy == 'blue_green' && steps.health_check.outputs.health_status == 'healthy'
        run: |
          echo "üîÑ Switching traffic to ${{ steps.deploy.outputs.next_color }} environment"
          
          # Get load balancer ARN
          LB_ARN=$(aws elbv2 describe-load-balancers \
            --names tyrehero-emergency-alb \
            --query 'LoadBalancers[0].LoadBalancerArn' \
            --output text)
          
          # Get listener ARN
          LISTENER_ARN=$(aws elbv2 describe-listeners \
            --load-balancer-arn $LB_ARN \
            --query 'Listeners[0].ListenerArn' \
            --output text)
          
          # Get next target group ARN
          NEXT_TG_ARN=$(aws elbv2 describe-target-groups \
            --names "${{ steps.deploy.outputs.next_color == 'blue' && env.BLUE_TARGET_GROUP || env.GREEN_TARGET_GROUP }}" \
            --query 'TargetGroups[0].TargetGroupArn' \
            --output text)
          
          # Switch traffic
          aws elbv2 modify-listener \
            --listener-arn $LISTENER_ARN \
            --default-actions Type=forward,TargetGroupArn=$NEXT_TG_ARN
          
          echo "‚úÖ Traffic switched to ${{ steps.deploy.outputs.next_color }} environment"
      
      - name: Post-Deployment Verification
        run: |
          echo "üîç Performing post-deployment verification..."
          
          # Test critical emergency service endpoints
          ENDPOINTS=(
            "https://api.tyrehero.com/health"
            "https://api.tyrehero.com/api/emergency/status"
            "https://emergency.tyrehero.com/health"
          )
          
          for endpoint in "${ENDPOINTS[@]}"; do
            echo "Testing $endpoint..."
            HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$endpoint")
            
            if [ "$HTTP_STATUS" == "200" ]; then
              echo "‚úÖ $endpoint: HTTP $HTTP_STATUS"
            else
              echo "‚ùå $endpoint: HTTP $HTTP_STATUS"
              echo "deployment_verified=false" >> $GITHUB_OUTPUT
              exit 1
            fi
          done
          
          # Test emergency request flow (synthetic transaction)
          echo "üß™ Testing emergency request flow..."
          RESPONSE=$(curl -s -X POST https://api.tyrehero.com/api/emergency/test \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer ${{ secrets.API_TEST_TOKEN }}" \
            -d '{"test": true, "location": "London", "issue": "flat"}')
          
          if echo "$RESPONSE" | jq -e '.success' > /dev/null; then
            echo "‚úÖ Emergency request flow test passed"
            echo "deployment_verified=true" >> $GITHUB_OUTPUT
          else
            echo "‚ùå Emergency request flow test failed"
            echo "deployment_verified=false" >> $GITHUB_OUTPUT
            exit 1
          fi

  # Rollback on Failure
  rollback:
    runs-on: ubuntu-latest
    needs: [pre_deployment, deploy]
    if: failure() && needs.pre_deployment.outputs.should_deploy == 'true'
    
    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Emergency Rollback
        run: |
          echo "üö® EMERGENCY ROLLBACK INITIATED"
          
          # Get previous stable task definition
          PREVIOUS_TASK_DEF=$(aws ecs describe-services \
            --cluster $ECS_CLUSTER \
            --services $ECS_SERVICE \
            --query 'services[0].deployments[1].taskDefinition' \
            --output text)
          
          if [ "$PREVIOUS_TASK_DEF" != "None" ] && [ "$PREVIOUS_TASK_DEF" != "" ]; then
            echo "Rolling back to: $PREVIOUS_TASK_DEF"
            
            aws ecs update-service \
              --cluster $ECS_CLUSTER \
              --service $ECS_SERVICE \
              --task-definition $PREVIOUS_TASK_DEF \
              --force-new-deployment
            
            # Wait for rollback to complete
            aws ecs wait services-stable \
              --cluster $ECS_CLUSTER \
              --services $ECS_SERVICE
            
            echo "‚úÖ Rollback completed successfully"
          else
            echo "‚ùå No previous stable deployment found for rollback"
          fi
      
      - name: Notify Rollback
        run: |
          curl -X POST $SLACK_EMERGENCY_WEBHOOK \
            -H 'Content-type: application/json' \
            --data '{
              "text": "üö® EMERGENCY ROLLBACK COMPLETED",
              "attachments": [{
                "color": "danger",
                "fields": [{
                  "title": "Deployment ID",
                  "value": "'${{ needs.pre_deployment.outputs.deployment_id }}'",
                  "short": true
                }, {
                  "title": "Reason",
                  "value": "Deployment failure detected",
                  "short": true
                }, {
                  "title": "Action Required",
                  "value": "Investigate deployment logs and fix issues",
                  "short": false
                }]
              }]
            }'

  # Cleanup and Notification
  cleanup:
    runs-on: ubuntu-latest
    needs: [pre_deployment, deploy]
    if: always() && needs.pre_deployment.outputs.should_deploy == 'true'
    
    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Cleanup Old Task Definitions
        run: |
          echo "üßπ Cleaning up old task definitions..."
          
          # Keep only the latest 10 task definitions
          aws ecs list-task-definitions \
            --family-prefix tyrehero-emergency \
            --status ACTIVE \
            --sort DESC \
            --query 'taskDefinitionArns[10:]' \
            --output text | \
          while read -r task_def; do
            if [ "$task_def" != "" ]; then
              echo "Deregistering: $task_def"
              aws ecs deregister-task-definition --task-definition "$task_def"
            fi
          done
      
      - name: Cleanup Old Docker Images
        run: |
          echo "üóëÔ∏è Cleaning up old Docker images..."
          
          # Keep only the latest 20 images in ECR
          aws ecr list-images \
            --repository-name $ECR_REPOSITORY \
            --filter tagStatus=TAGGED \
            --query 'imageIds[20:]' \
            --output json | \
          jq -r '.[] | select(.imageTag != "latest") | .imageTag' | \
          while read -r tag; do
            if [ "$tag" != "" ] && [ "$tag" != "latest" ]; then
              echo "Deleting image tag: $tag"
              aws ecr batch-delete-image \
                --repository-name $ECR_REPOSITORY \
                --image-ids imageTag=$tag
            fi
          done
      
      - name: Send Success Notification
        if: success()
        run: |
          curl -X POST $SLACK_WEBHOOK \
            -H 'Content-type: application/json' \
            --data '{
              "text": "‚úÖ Emergency Service Deployment Successful",
              "attachments": [{
                "color": "good",
                "fields": [{
                  "title": "Deployment ID",
                  "value": "'${{ needs.pre_deployment.outputs.deployment_id }}'",
                  "short": true
                }, {
                  "title": "Image",
                  "value": "'${{ needs.build_push.outputs.image_tag }}'",
                  "short": true
                }, {
                  "title": "Duration",
                  "value": "Deployment completed in under 10 minutes",
                  "short": true
                }, {
                  "title": "Health Status",
                  "value": "All endpoints healthy ‚úÖ",
                  "short": true
                }]
              }]
            }'
      
      - name: Send Failure Notification
        if: failure()
        run: |
          curl -X POST $SLACK_EMERGENCY_WEBHOOK \
            -H 'Content-type: application/json' \
            --data '{
              "text": "‚ùå Emergency Service Deployment Failed",
              "attachments": [{
                "color": "danger",
                "fields": [{
                  "title": "Deployment ID",
                  "value": "'${{ needs.pre_deployment.outputs.deployment_id }}'",
                  "short": true
                }, {
                  "title": "Failure Stage",
                  "value": "Check GitHub Actions logs for details",
                  "short": true
                }, {
                  "title": "Action Required",
                  "value": "Emergency team investigation required",
                  "short": false
                }]
              }]
            }'